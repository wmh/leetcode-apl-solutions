{
  "number": 78,
  "title": "Subsets",
  "difficulty": "medium",
  "description": {
    "en": "Return all possible subsets",
    "zh-CN": "Return all possible subsets",
    "zh-TW": "Return all possible subsets",
    "ja": "Return all possible subsets",
    "es": "Return all possible subsets",
    "de": "Return all possible subsets",
    "fr": "Return all possible subsets"
  },
  "aplSolution": "Subsets ← {↓⍉(≢⍵)⊤⍳2*≢⍵}",
  "explanation": {
    "en": "Generate all subsets using binary representation. Step 1: ≢⍵ gets array length n. Step 2: 2*≢⍵ computes 2^n (total number of subsets). Step 3: ⍳2*≢⍵ generates range [0,1,2,...,2^n-1]. Step 4: (≢⍵)⊤ converts each number to base-n representation, giving n binary digits for each number. Step 5: ⍉ transposes so each column is a binary pattern. Step 6: ↓ splits into separate arrays. Each binary pattern [1,0,1,0] indicates which elements to include in that subset. For n=3: patterns 000,001,010,011,100,101,110,111 represent all 8 subsets.",
    "zh-CN": "使用二进制表示生成所有子集。步骤 1：≢⍵ 获取数组长度 n。步骤 2：2*≢⍵ 计算 2^n（子集总数）。步骤 3：⍳2*≢⍵ 生成范围 [0,1,2,...,2^n-1]。步骤 4：(≢⍵)⊤ 将每个数字转换为 n 进制表示，为每个数字提供 n 个二进制位。步骤 5：⍉ 转置使每列是一个二进制模式。步骤 6：↓ 分割成单独的数组。每个二进制模式 [1,0,1,0] 指示该子集中包含哪些元素。对于 n=3：模式 000,001,010,011,100,101,110,111 表示所有 8 个子集。",
    "zh-TW": "使用二進制表示生成所有子集。步驟 1：≢⍵ 獲取陣列長度 n。步驟 2：2*≢⍵ 計算 2^n（子集總數）。步驟 3：⍳2*≢⍵ 生成範圍 [0,1,2,...,2^n-1]。步驟 4：(≢⍵)⊤ 將每個數字轉換為 n 進制表示，為每個數字提供 n 個二進制位。步驟 5：⍉ 轉置使每列是一個二進制模式。步驟 6：↓ 分割成單獨的陣列。每個二進制模式 [1,0,1,0] 指示該子集中包含哪些元素。對於 n=3：模式 000,001,010,011,100,101,110,111 表示所有 8 個子集。",
    "ja": "Generate all subsets using binary representation. Step 1: ≢⍵ gets array length n. Step 2: 2*≢⍵ computes 2^n (total number of subsets). Step 3: ⍳2*≢⍵ generates range [0,1,2,...,2^n-1]. Step 4: (≢⍵)⊤ converts each number to base-n representation, giving n binary digits for each number. Step 5: ⍉ transposes so each column is a binary pattern. Step 6: ↓ splits into separate arrays. Each binary pattern [1,0,1,0] indicates which elements to include in that subset. For n=3: patterns 000,001,010,011,100,101,110,111 represent all 8 subsets.",
    "es": "Generate all subsets using binary representation. Step 1: ≢⍵ gets array length n. Step 2: 2*≢⍵ computes 2^n (total number of subsets). Step 3: ⍳2*≢⍵ generates range [0,1,2,...,2^n-1]. Step 4: (≢⍵)⊤ converts each number to base-n representation, giving n binary digits for each number. Step 5: ⍉ transposes so each column is a binary pattern. Step 6: ↓ splits into separate arrays. Each binary pattern [1,0,1,0] indicates which elements to include in that subset. For n=3: patterns 000,001,010,011,100,101,110,111 represent all 8 subsets.",
    "de": "Generate all subsets using binary representation. Step 1: ≢⍵ gets array length n. Step 2: 2*≢⍵ computes 2^n (total number of subsets). Step 3: ⍳2*≢⍵ generates range [0,1,2,...,2^n-1]. Step 4: (≢⍵)⊤ converts each number to base-n representation, giving n binary digits for each number. Step 5: ⍉ transposes so each column is a binary pattern. Step 6: ↓ splits into separate arrays. Each binary pattern [1,0,1,0] indicates which elements to include in that subset. For n=3: patterns 000,001,010,011,100,101,110,111 represent all 8 subsets.",
    "fr": "Generate all subsets using binary representation. Step 1: ≢⍵ gets array length n. Step 2: 2*≢⍵ computes 2^n (total number of subsets). Step 3: ⍳2*≢⍵ generates range [0,1,2,...,2^n-1]. Step 4: (≢⍵)⊤ converts each number to base-n representation, giving n binary digits for each number. Step 5: ⍉ transposes so each column is a binary pattern. Step 6: ↓ splits into separate arrays. Each binary pattern [1,0,1,0] indicates which elements to include in that subset. For n=3: patterns 000,001,010,011,100,101,110,111 represent all 8 subsets."
  },
  "timeComplexity": "O(2^n)",
  "spaceComplexity": "O(2^n)",
  "verified": false,
  "testCases": []
}